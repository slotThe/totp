# XXX The whole implementation uses bit-vectors instead of calling â€¢bit,
# because I wanted to stay sane while writing this.

# Number n to base b with minimal length p. If p is a function, it is called
# with the result vector as its argument to decide upon a length.
TB â‡ { bâ€¿p ğ•Š n: n{ 0ğ•Šr: rÂ«(P r)â¥Š0; xğ•Šr: (âŒŠxÃ·b) ğ•Š râˆ¾Ëœb|x }âŸ¨âŸ© }
XOR â† â‰ 
HtB â† { 2â€¿32 TB 16âŠ¸Ã—âŠ¸+ËœÂ´âŒ½(âˆ¾"0A"+âŸœâ†•Â¨10â€¿6)âŠğ•© } # Hex to bit

SHA1 â‡ { # https://datatracker.ietf.org/doc/html/rfc3174
  ms â† ğ•©

  F â† { # f(t; B, C, D)
    t ğ•Š âŸ¨b,c,dâŸ©: tâ‰¤19? (dâˆ§Â¬b) âˆ¨ bâˆ§c       ;
    t ğ•Š âŸ¨b,c,dâŸ©: tâ‰¤39? d XOR c XOR b      ;
    t ğ•Š âŸ¨b,c,dâŸ©: tâ‰¤59? (dâˆ§c) âˆ¨ (dâˆ§b) âˆ¨ câˆ§b;
    t ğ•Š âŸ¨b,c,dâŸ©: tâ‰¤79? d XOR c XOR b
  }
  K â† { # K(t)
    ğ•©â‰¤19? HtB "5A827999";
    ğ•©â‰¤39? HtB "6ED9EBA1";
    ğ•©â‰¤59? HtB "8F1BBCDC";
    ğ•©â‰¤79? HtB "CA62C1D6"
  }
  S â† âŒ½                           # Circular shift S
  P â† 32â€¿1â€¢bit._addâŒ¾âŒ½             # Adding bit vectors

  # Method 1 in the RFC
  ms âˆ¾â†© 1 âˆ¾ ((512|-l+65)â¥Š0) âˆ¾ 2â€¿64 TB (lâ†â‰ ms) # Pad to multiples of 512
  hs â† HtBÂ¨ âŸ¨"67452301","EFCDAB89","98BADCFE","10325476","C3D2E1F0"âŸ©
  { ws â† ğ•©
    W  â† {ğ•©âŠws} # Block important here
    {ws âˆ¾â†© 1 S (Wğ•©-16) XOR (Wğ•©-14) XOR (Wğ•©-8) XOR (Wğ•©-3) â‹„@}Â¨16+â†•64
    âŸ¨a,b,c,d,eâŸ© â† hs
    {temp â† (Kğ•©) P (Wğ•©) P e P (ğ•© F bâ€¿câ€¿d) P (5 S a)
     eâ†©d â‹„ dâ†©c â‹„ câ†©30 S b â‹„ bâ†©a â‹„ aâ†©temp â‹„@}Â¨â†•80
    hs PÂ¨â†© âŸ¨a,b,c,d,eâŸ©
    @
  }Ë˜ âˆ˜â€¿16â€¿32â¥Šms # Groups of 16 words: M(1) to M(n)
  âˆ¾hs # Result as binary string
}

HMAC â‡ { k ğ•Š text: # https://datatracker.ietf.org/doc/html/rfc2104
  "HMAC: key should not exceed block length of SHA1" ! 512â‰¥â‰ k
  k â†© 512â†‘k                # Pad to 64 bytes
  P â† { âˆ¾ 64â¥Š < 24â†“ HtBğ•© } # ipad and opad
  SHA1 (k XOR P"5C") âˆ¾ SHA1 (k XOR P"36")âˆ¾text
}

B32d â‡ { # Base32 decoding; https://datatracker.ietf.org/doc/html/rfc4648
  âˆ¾Ë âŒŠâ€¿8â¥Š âˆ¾ 2â€¿5âŠ¸TBâˆ˜(âŠ‘(('A'+â†•26)âˆ¾'0'+2+â†•6)âŠ¸âŠ)Â¨ '='âŠ¸â‰ âŠ¸/ ğ•©
  # To binary in 5-bit slices, then to bytes and drop excess.
}

HOTP â‡ { k ğ•Š c: # https://datatracker.ietf.org/doc/html/rfc4226
  hm â† (B32d k) HMAC 2â€¿64 TB c
  # Turn low-order 4-bits to number n and then take the bytes hm[n] to
  # hm[n+3], keeping in mind hm has a flat representation.
  p  â† (8Ã—2âŠ¸Ã—âŠ¸+ËœÂ´âŒ½Â¯4â†‘hm)+â†•8Ã—4
  r  â† (10â‹†6)| 2âŠ¸Ã—âŠ¸+ËœÂ´âŒ½ 1â†“ pâŠhm # Take last 31 bits only.
  '0'+ 10â€¿6 TB r
}

TOTP â‡ { # https://datatracker.ietf.org/doc/html/rfc6238
  ğ•© HOTP âŒŠ30Ã·Ëœâ€¢UnixTime@
}
